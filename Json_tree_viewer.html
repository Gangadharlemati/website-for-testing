
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON Tree Viewer & Exporter</title>
    <style>
        :root {
            /* Light Theme */
            --bg-color: #fafafa;
            --text-color: #000000;
            --header-bg: #e0e0e0;
            --header-border: #cccccc;
            --tab-text: #555555;
            --tab-active-bg: #e0e0e0;
            --tab-active-text: #000000;
            --editor-bg: #fafafa;
            --tree-bg: #fafafa;
            --scrollbar-track: #efefef;
            --scrollbar-thumb: #c0c0c0;
            --scrollbar-thumb-hover: #a0a0a0;
            --line-color: #d0d0d0;
            
            --key-color: #001080;
            --colon-color: #000000;
            --string-color: #a31515;
            --number-color: #098658;
            --boolean-color: #0000ff;
            --null-color: #0000ff;
            --bracket-color: #6a6a6a;
            --count-color: #808080;

            --icon-object: #795E26;
            --icon-array: #098658;
            --icon-prop: #0451A5;
            --icon-toggle-bg: #e0e0e0;
            --icon-toggle-stroke: #a0a0a0;
            --icon-toggle-path: #000000;

            --search-bg: #ffffff;
            --search-border: #bbbbbb;
            --highlight-bg: #fff176;
            --highlight-text: #000000;
            
            --menu-bg: #ffffff;
            --menu-border: #cccccc;
            --menu-hover: #e6f7ff;
            --menu-text: #333333;
            --menu-shadow: rgba(0,0,0,0.2);

            --table-header-bg: #d0d0d0;
            --table-border: #cccccc;
            --table-stripe: #f0f0f0;
        }

        body.dark {
            /* Dark Theme */
            --bg-color: #121212;
            --text-color: #d4d4d4;
            --header-bg: #1e1e1e;
            --header-border: #333333;
            --tab-text: #969696;
            --tab-active-bg: #1e1e1e;
            --tab-active-text: #ffffff;
            --editor-bg: #181818;
            --tree-bg: #181818;
            --scrollbar-track: #181818;
            --scrollbar-thumb: #424242;
            --scrollbar-thumb-hover: #4e4e4e;
            --line-color: #3e3e42;
            
            --key-color: #9cdcfe;
            --colon-color: #d4d4d4;
            --string-color: #ce9178;
            --number-color: #b5cea8;
            --boolean-color: #569cd6;
            --null-color: #569cd6;
            --bracket-color: #808080;
            --count-color: #6a6a6a;

            --icon-object: #DCAA50;
            --icon-array: #4EC9B0;
            --icon-prop: #9CDCFE;
            --icon-toggle-bg: #505050;
            --icon-toggle-stroke: #808080;
            --icon-toggle-path: #d4d4d4;

            --search-bg: #2d2d2d;
            --search-border: #444444;
            --highlight-bg: #665d1d;
            --highlight-text: #ffffff;
            
            --menu-bg: #252526;
            --menu-border: #454545;
            --menu-hover: #094771;
            --menu-text: #cccccc;
            --menu-shadow: rgba(0,0,0,0.5);

            --table-header-bg: #333333;
            --table-border: #444444;
            --table-stripe: #1f1f1f;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            overflow: hidden;
            transition: background-color 0.3s; 
        }

        .container { 
            display: flex; 
            flex-direction: column; 
            height: 100vh; 
            zoom: 0.9; 
        }

        /* Tabs */
        .tabs { 
            display: flex; 
            background: var(--header-bg); 
            border-bottom: 1px solid var(--header-border); 
            flex-shrink: 0; /* Prevent header from shrinking */
        }
        .tab {
            padding: 12px 24px; cursor: pointer; background: transparent; border: none;
            color: var(--tab-text); font-size: 13px; font-family: inherit;
            border-bottom: 1px solid transparent; transition: all 0.2s;
        }
        .tab:hover { color: var(--text-color); }
        .tab.active { color: var(--tab-active-text); background: var(--tab-active-bg); border-bottom: 1px solid #007acc; }

        /* Tab Content Area */
        .tab-content { 
            display: none; 
            flex: 1; 
            overflow: hidden; 
            position: relative; 
            min-height: 0; /* Critical for nested flex scrolling */
        }
        .tab-content.active { 
            display: flex; 
            flex-direction: column; 
        }

        /* Text Editor Tab */
        .text-editor { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            min-height: 0; /* Fix for textarea height bug */
        }
        .toolbar {
            background: var(--header-bg); padding: 8px 12px;
            border-bottom: 1px solid var(--header-border); display: flex; gap: 8px; align-items: center;
            flex-shrink: 0;
        }
        .toolbar button {
            padding: 6px 12px; background: #007acc; color: #ffffff; border: none;
            border-radius: 2px; cursor: pointer; font-size: 12px; font-family: inherit;
        }
        .toolbar button:hover { background: #005a9e; }
        .toolbar button.secondary { background: #6c6c6c; }
        .toolbar button.secondary:hover { background: #5a5a5a; }
        .toolbar button.theme-toggle { background: #6c6c6c; margin-left: auto; padding: 6px 10px; font-size: 16px; min-width: 32px; }

        textarea {
            flex: 1; 
            background: var(--editor-bg); 
            color: var(--text-color); 
            border: none;
            padding: 16px; 
            font-family: inherit; font-size: 14px; 
            resize: none; outline: none; white-space: pre; 
            overflow: auto;
            height: 100%; /* Ensure full height */
        }
        textarea::placeholder { color: var(--count-color); }

        /* Viewer Tab */
        .tree-viewer { 
            flex: 1; 
            overflow: auto; 
            padding: 16px; 
            background: var(--tree-bg); 
            white-space: nowrap; 
        }
        .tree-viewer.wrap-text { white-space: normal; word-wrap: break-word; }

        /* Export Tab */
        .export-controls { flex: 1; display: flex; flex-direction: column; overflow: hidden; min-height: 0; }
        .array-selector {
            padding: 6px; background: var(--search-bg); color: var(--text-color);
            border: 1px solid var(--header-border); border-radius: 2px; font-family: inherit; min-width: 200px;
        }
        .table-container { 
            flex: 1; 
            overflow: auto; 
            padding: 0; 
            background: var(--tree-bg); 
        }
        
        /* Table Styles */
        table { border-collapse: collapse; width: 100%; font-size: 13px; }
        th, td { 
            padding: 8px 12px; 
            border: 1px solid var(--table-border); 
            text-align: left; 
            white-space: nowrap; 
        }
        th { 
            background: var(--table-header-bg); 
            position: sticky; 
            top: 0; 
            z-index: 2; 
            font-weight: bold; 
            color: var(--text-color);
        }
        tr:nth-child(even) { background: var(--table-stripe); }
        td { color: var(--text-color); }

        /* Footer & Search */
        .viewer-footer {
            background: var(--header-bg); padding: 4px 12px;
            border-top: 1px solid var(--header-border); font-size: 12px; color: var(--count-color);
            display: flex; align-items: center; justify-content: space-between; height: 40px; z-index: 5;
            flex-shrink: 0;
        }
        .search-container {
            display: flex; align-items: center; gap: 6px; background: var(--search-bg);
            border: 1px solid var(--search-border); padding: 2px 4px; border-radius: 3px;
        }
        .search-container input {
            background: transparent; border: none; color: var(--text-color);
            font-family: inherit; font-size: 12px; width: 160px; outline: none;
        }
        .search-btn {
            background: transparent; border: none; color: var(--tab-text); cursor: pointer;
            padding: 2px 6px; font-size: 12px; border-radius: 2px;
        }
        .search-btn:hover { background: rgba(128,128,128,0.2); color: var(--text-color); }
        .search-count { min-width: 90px; text-align: center; font-size: 11px; }

        .floating-wrap-btn {
            position: absolute; bottom: 50px; right: 20px; width: 36px; height: 36px;
            border-radius: 50%; background: #007acc; color: white; border: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3); cursor: pointer; display: flex; align-items: center; justify-content: center;
            font-size: 18px; transition: transform 0.2s, background 0.2s; z-index: 10; opacity: 0.9;
        }
        .floating-wrap-btn:hover { transform: scale(1.1); background: #005a9e; opacity: 1; }

        /* Scrollbars */
        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-track { background: var(--scrollbar-track); }
        ::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 5px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }

        /* Tree UI Elements */
        .tree-node { position: relative; margin-left: 20px; cursor: default; }
        .tree-node.root { margin-left: 0; }
        .tree-item { display: flex; align-items: center; gap: 6px; min-height: 24px; position: relative; padding: 2px 0; border-radius: 2px; border: 1px solid transparent; }
        .tree-item:hover { background: rgba(128, 128, 128, 0.1); }
        .tree-item.search-highlight { background-color: var(--highlight-bg); border: 1px solid #ffd700; }
        .tree-item.search-highlight * { color: var(--highlight-text) !important; }
        .tree-item.search-highlight svg text, .tree-item.search-highlight svg rect, .tree-item.search-highlight svg path { fill: var(--highlight-text); stroke: var(--highlight-text); }
        .tree-line { position: absolute; left: -11px; top: 0; bottom: 0; width: 1px; background: var(--line-color); }
        .tree-node:last-child > .tree-line { bottom: auto; height: 12px; }
        .tree-item::before { content: ''; position: absolute; left: -11px; top: 12px; width: 11px; height: 1px; background: var(--line-color); }
        .tree-node.root > .tree-item::before { display: none; }
        .toggle { width: 20px; height: 20px; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; flex-shrink: 0; user-select: none; }
        .toggle:hover { opacity: 0.8; }
        .toggle.empty { pointer-events: none; opacity: 0; }
        .icon-svg { width: 18px; height: 18px; flex-shrink: 0; }
        .tree-key { color: var(--key-color); }
        .tree-colon { color: var(--colon-color); margin: 0 4px; }
        .tree-value { color: var(--string-color); }
        .tree-value.number { color: var(--number-color); }
        .tree-value.boolean { color: var(--boolean-color); }
        .tree-value.null { color: var(--null-color); }
        .tree-bracket { color: var(--bracket-color); margin-left: 6px; }
        .tree-count { color: var(--count-color); font-size: 11px; }
        .tree-inline { display: inline-flex; align-items: center; gap: 4px; }
        .tree-children { margin-left: 0; }
        .tree-children.hidden { display: none; }
        .empty-state { display: flex; align-items: center; justify-content: center; height: 100%; color: var(--count-color); font-size: 14px; }
        .error-message { color: #e51400; background: #3a1b1b; padding: 12px; margin: 16px; border-left: 3px solid #e51400; font-size: 13px; }
        .context-menu { position: fixed; z-index: 1000; background: var(--menu-bg); border: 1px solid var(--menu-border); box-shadow: 0 4px 10px var(--menu-shadow); border-radius: 4px; display: none; min-width: 160px; padding: 4px 0; font-size: 13px; color: var(--menu-text); }
        .context-menu.visible { display: block; }
        .menu-item { padding: 8px 16px; cursor: pointer; display: flex; align-items: center; justify-content: space-between; }
        .menu-item:hover { background: var(--menu-hover); }
        .menu-separator { height: 1px; background: var(--menu-border); margin: 4px 0; }
    </style>
</head>
<body>
    <div class="container">
        <div class="tabs">
            <button class="tab active" onclick="switchTab('text')">Text</button>
            <button class="tab" onclick="switchTab('viewer')">Viewer</button>
            <button class="tab" onclick="switchTab('export')">Table / Export</button>
        </div>

        <div id="text-tab" class="tab-content active">
            <div class="text-editor">
                <div class="toolbar">
                    <button class="secondary" onclick="triggerUpload()">Upload File</button>
                    <input type="file" id="fileInput" hidden accept=".json,.txt" onchange="handleFile(this)">
                    <button onclick="formatJSON()">Format</button>
                    <button onclick="clearText()">Clear</button>
                    <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">◐</button>
                </div>
                <textarea id="jsonInput" placeholder="Paste your JSON here or click Upload File..."></textarea>
            </div>
        </div>

        <div id="viewer-tab" class="tab-content">
            <button class="floating-wrap-btn" onclick="toggleWrap()" title="Toggle text wrapping">↔</button>
            <div id="contextMenu" class="context-menu">
                <div class="menu-item" onclick="handleMenuAction('copyValue')">Copy Value</div>
                <div class="menu-item" onclick="handleMenuAction('copyPath')">Copy Path</div>
                <div class="menu-separator"></div>
                <div class="menu-item" onclick="handleMenuAction('expandAll')">Expand Recursive</div>
                <div class="menu-item" onclick="handleMenuAction('collapseAll')">Collapse Recursive</div>
            </div>
            <div class="tree-viewer" id="treeViewer">
                <div class="empty-state">No JSON data to display. Paste JSON in Text tab.</div>
            </div>
            <div class="viewer-footer" id="viewerFooter">
                <div id="statusText">Ready</div>
                <div class="search-container">
                    <input type="text" id="searchInput" placeholder="Search..." onkeydown="if(event.key === 'Enter') performSearch()">
                    <span class="search-count" id="searchCount"></span>
                    <button class="search-btn" onclick="prevMatch()" title="Previous Match">▲</button>
                    <button class="search-btn" onclick="nextMatch()" title="Next Match">▼</button>
                    <button class="search-btn" onclick="resetSearch()" title="Clear">✕</button>
                </div>
            </div>
        </div>

        <div id="export-tab" class="tab-content">
            <div class="export-controls">
                <div class="toolbar">
                    <span style="font-size:12px; color:var(--tab-text)">Select Array:</span>
                    <select id="arraySelector" class="array-selector" onchange="renderTable()"></select>
                    <button onclick="downloadCSV()">Download CSV</button>
                </div>
                <div class="table-container" id="tableContainer">
                    <div class="empty-state">No array selected.</div>
                </div>
            </div>
            <div class="viewer-footer">
                <div id="exportStatus">Ready</div>
            </div>
        </div>
    </div>

    <script>
        let currentTab = 'text';
        let jsonData = null;
        let parseTimeout = null;
        let contextNode = null;
        let searchResults = [];
        let currentMatchIndex = -1;
        let lastSearchTerm = '';
        let foundArrays = [];

        const svgs = {
            object: `<svg class="icon-svg" viewBox="0 0 18 18" fill="none"><text x="9" y="14" font-family="Consolas, monospace" font-size="15" font-weight="bold" fill="var(--icon-object)" text-anchor="middle">{}</text></svg>`,
            array: `<svg class="icon-svg" viewBox="0 0 18 18" fill="none"><text x="9" y="14" font-family="Consolas, monospace" font-size="15" font-weight="bold" fill="var(--icon-array)" text-anchor="middle">[]</text></svg>`,
            property: `<svg class="icon-svg" viewBox="0 0 18 18" fill="none"><rect x="5" y="5" width="8" height="8" rx="1" fill="var(--icon-prop)"/></svg>`,
            collapsed: `<svg class="icon-svg" viewBox="0 0 20 20" fill="none"><rect x="3" y="3" width="14" height="14" rx="2" fill="var(--icon-toggle-bg)" stroke="var(--icon-toggle-stroke)" stroke-width="1"/><path d="M10 7V13M7 10H13" stroke="var(--icon-toggle-path)" stroke-width="2" stroke-linecap="round"/></svg>`,
            expanded: `<svg class="icon-svg" viewBox="0 0 20 20" fill="none"><rect x="3" y="3" width="14" height="14" rx="2" fill="var(--icon-toggle-bg)" stroke="var(--icon-toggle-stroke)" stroke-width="1"/><path d="M7 10H13" stroke="var(--icon-toggle-path)" stroke-width="2" stroke-linecap="round"/></svg>`
        };

        document.getElementById('jsonInput').addEventListener('input', function() {
            clearTimeout(parseTimeout);
            parseTimeout = setTimeout(parseAndDisplayTree, 500);
        });

        const treeViewer = document.getElementById('treeViewer');
        treeViewer.addEventListener('click', function(e) {
            const toggleBtn = e.target.closest('.toggle');
            if (toggleBtn && !toggleBtn.classList.contains('empty')) handleToggle(toggleBtn);
            hideContextMenu();
        });
        treeViewer.addEventListener('contextmenu', function(e) {
            const target = e.target.closest('.tree-item');
            if (!target) return;
            e.preventDefault();
            const toggleBtn = target.querySelector('.toggle');
            if (!toggleBtn) return;
            const pathStr = toggleBtn.getAttribute('data-path');
            const pathArray = pathStr ? JSON.parse(pathStr.replace(/&quot;/g, '"')) : [];
            const isExpandable = !toggleBtn.classList.contains('empty');
            contextNode = { path: pathArray, element: toggleBtn, isExpandable: isExpandable };
            showContextMenu(e.clientX, e.clientY);
        });
        document.addEventListener('click', hideContextMenu);
        document.addEventListener('scroll', hideContextMenu, true);

        // --- Core ---
        function switchTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`${tab}-tab`).classList.add('active');
            currentTab = tab;
            if (tab === 'export' && jsonData) populateArraySelector();
        }
        function formatJSON() {
            const el = document.getElementById('jsonInput');
            if (!el.value.trim()) return;
            try {
                const parsed = JSON.parse(el.value);
                el.value = JSON.stringify(parsed, null, 2);
                parseAndDisplayTree();
            } catch (e) { alert('Invalid JSON: ' + e.message); }
        }
        function clearText() { document.getElementById('jsonInput').value = ''; }
        function toggleTheme() {
            document.body.classList.toggle('dark');
            localStorage.setItem('theme', document.body.classList.contains('dark') ? 'dark' : 'light');
        }
        function toggleWrap() { document.getElementById('treeViewer').classList.toggle('wrap-text'); }
        function parseAndDisplayTree() {
            const input = document.getElementById('jsonInput').value.trim();
            const viewer = document.getElementById('treeViewer');
            const status = document.getElementById('statusText');
            if (!input) {
                viewer.innerHTML = '<div class="empty-state">No JSON data to display. Paste JSON in Text tab.</div>';
                status.textContent = 'Ready';
                jsonData = null;
                resetSearchState();
                foundArrays = [];
                return;
            }
            try {
                jsonData = JSON.parse(input);
                resetSearchState();
                viewer.innerHTML = buildNodeHTML(jsonData, 'root', [], false, false);
                const size = input.length;
                const sizeStr = size > 1024*1024 ? (size/1024/1024).toFixed(2)+' MB' : (size/1024).toFixed(2)+' KB';
                status.textContent = `Parsed successfully (${sizeStr})`;
                foundArrays = [];
                scanForArrays(jsonData, []);
            } catch (e) {
                viewer.innerHTML = `<div class="error-message"><strong>Error parsing JSON:</strong><br>${escapeHtml(e.message)}</div>`;
                status.textContent = 'Error';
            }
        }

        // --- Export Logic ---
        function scanForArrays(data, path) {
            if (Array.isArray(data)) {
                if (data.length > 0) foundArrays.push({ path: path, length: data.length });
                data.forEach((item, i) => { if (typeof item === 'object' && item !== null) scanForArrays(item, [...path, i]); });
            } else if (typeof data === 'object' && data !== null) {
                Object.keys(data).forEach(key => scanForArrays(data[key], [...path, key]));
            }
        }
        function populateArraySelector() {
            const sel = document.getElementById('arraySelector');
            sel.innerHTML = '';
            if (!jsonData || foundArrays.length === 0) { sel.innerHTML = '<option>No arrays found</option>'; return; }
            foundArrays.forEach((item, index) => {
                const opt = document.createElement('option');
                opt.value = index;
                let pathStr = item.path.join('.') || "root";
                opt.textContent = `${pathStr} (${item.length} items)`;
                sel.appendChild(opt);
            });
            renderTable();
        }

        // Recursive flattening with Cartesian explosion for nested arrays
        function flattenItem(item, prefix = '') {
            let base = {};
            let arrays = {};
            let hasArrays = false;

            // 1. Separate Scalars vs Arrays
            for (let key in item) {
                if (!Object.prototype.hasOwnProperty.call(item, key)) continue;
                let val = item[key];
                let newKey = prefix + key;
                
                if (Array.isArray(val)) {
                    arrays[newKey] = val;
                    hasArrays = true;
                } else if (typeof val === 'object' && val !== null) {
                    // Recurse object
                    let flatObj = flattenItem(val, newKey + '.');
                    // flatObj returns Array of rows, but since 'val' is a single object, it returns [ {..} ]
                    // We merge that single object into base
                    if (flatObj.length > 0) Object.assign(base, flatObj[0]);
                } else {
                    base[newKey] = val;
                }
            }

            if (!hasArrays) return [base];

            // 2. Cartesian Product
            // Start with the base row
            let rows = [base];

            for (let arrKey in arrays) {
                let subArray = arrays[arrKey];
                let newRows = [];
                
                if (subArray.length === 0) {
                    // Empty array -> keep parent row
                    newRows = rows; 
                } else {
                    // For every existing row, explode it by the current array
                    for (let r of rows) {
                        for (let subItem of subArray) {
                            // Recursively flatten the item inside the array (it might be an object with more arrays)
                            let subRows = [];
                            if (typeof subItem === 'object' && subItem !== null) {
                                subRows = flattenItem(subItem, arrKey + '.');
                            } else {
                                // Primitive in array
                                let obj = {};
                                obj[arrKey] = subItem;
                                subRows = [obj];
                            }
                            
                            // Combine current parent row 'r' with exploded sub-rows
                            for (let sr of subRows) {
                                newRows.push({ ...r, ...sr });
                            }
                        }
                    }
                    rows = newRows;
                }
            }
            return rows;
        }

        function renderTable() {
            const sel = document.getElementById('arraySelector');
            const container = document.getElementById('tableContainer');
            const index = sel.value;
            if (index === undefined || !foundArrays[index]) { container.innerHTML = '<div class="empty-state">Select array.</div>'; return; }

            const arrInfo = foundArrays[index];
            const dataArr = getValueByPath(jsonData, arrInfo.path);
            if (!Array.isArray(dataArr) || dataArr.length === 0) { container.innerHTML = '<div class="empty-state">Empty.</div>'; return; }

            // Flatten Data
            let flattenedData = [];
            const isPrimitive = typeof dataArr[0] !== 'object' || dataArr[0] === null;

            if (isPrimitive) {
                dataArr.forEach(item => flattenedData.push({ 'Value': item }));
            } else {
                // Safety Limit for Preview
                const PREVIEW_LIMIT = 2000;
                for (let item of dataArr) {
                    let rows = flattenItem(item);
                    flattenedData.push(...rows);
                    if (flattenedData.length > PREVIEW_LIMIT) break;
                }
            }

            // Collect Headers
            const allKeys = new Set();
            flattenedData.forEach(row => Object.keys(row).forEach(k => allKeys.add(k)));
            const headers = Array.from(allKeys).sort();

            let html = '<table><thead><tr>';
            headers.forEach(h => html += `<th>${escapeHtml(h)}</th>`);
            html += '</tr></thead><tbody>';

            flattenedData.forEach(row => {
                html += '<tr>';
                headers.forEach(h => {
                    let val = row[h];
                    if (val === undefined) val = '';
                    else val = String(val);
                    html += `<td>${escapeHtml(val)}</td>`;
                });
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            if (flattenedData.length >= 2000) {
                html += `<div style="padding:10px;text-align:center;color:#e51400">Preview limited to 2000 rows. Download CSV to see all.</div>`;
            }
            container.innerHTML = html;
            document.getElementById('exportStatus').textContent = `${flattenedData.length} rows generated`;
        }

        function downloadCSV() {
            const sel = document.getElementById('arraySelector');
            const index = sel.value;
            if (index === undefined || !foundArrays[index]) return;

            const arrInfo = foundArrays[index];
            const dataArr = getValueByPath(jsonData, arrInfo.path);
            const isPrimitive = typeof dataArr[0] !== 'object' || dataArr[0] === null;
            let flattenedData = [];

            if (isPrimitive) {
                dataArr.forEach(item => flattenedData.push({ 'Value': item }));
            } else {
                dataArr.forEach(item => flattenedData.push(...flattenItem(item)));
            }

            const allKeys = new Set();
            flattenedData.forEach(row => Object.keys(row).forEach(k => allKeys.add(k)));
            const headers = Array.from(allKeys).sort();

            const csvRows = [headers.join(',')];
            flattenedData.forEach(row => {
                const values = headers.map(header => {
                    let val = row[header];
                    if (val === undefined) val = '';
                    const escaped = String(val).replace(/"/g, '""');
                    return `"${escaped}"`;
                });
                csvRows.push(values.join(','));
            });

            const blob = new Blob([csvRows.join('\n')], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', (arrInfo.path.join('_') || 'root') + '.csv');
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // --- Search & Tree (Existing) ---
        function performSearch() {
            const term = document.getElementById('searchInput').value.trim().toLowerCase();
            const countEl = document.getElementById('searchCount');
            document.querySelectorAll('.search-highlight').forEach(el => el.classList.remove('search-highlight'));
            if (!term || !jsonData) { resetSearchState(); return; }
            if (term !== lastSearchTerm) {
                searchResults = [];
                traverseForSearch(jsonData, [], term);
                lastSearchTerm = term;
                currentMatchIndex = -1;
            }
            if (searchResults.length > 0) nextMatch();
            else { countEl.textContent = 'No matches'; currentMatchIndex = -1; }
        }
        function resetSearchState() { searchResults = []; currentMatchIndex = -1; lastSearchTerm = ''; document.getElementById('searchCount').textContent = ''; }
        function traverseForSearch(data, currentPath, term) {
            if (data !== null && typeof data !== 'object') {
                if (String(data).toLowerCase().includes(term)) searchResults.push([...currentPath]);
                return;
            }
            if (typeof data === 'object' && data !== null) {
                if (Array.isArray(data)) data.forEach((item, index) => traverseForSearch(item, [...currentPath, index], term));
                else Object.keys(data).forEach(key => {
                    if (key.toLowerCase().includes(term)) searchResults.push([...currentPath, key]);
                    traverseForSearch(data[key], [...currentPath, key], term);
                });
            }
        }
        function nextMatch() {
            if (searchResults.length === 0) return;
            currentMatchIndex++; if (currentMatchIndex >= searchResults.length) currentMatchIndex = 0;
            revealAndHighlight(currentMatchIndex);
        }
        function prevMatch() {
            if (searchResults.length === 0) return;
            currentMatchIndex--; if (currentMatchIndex < 0) currentMatchIndex = searchResults.length - 1;
            revealAndHighlight(currentMatchIndex);
        }
        function revealAndHighlight(index) {
            const path = searchResults[index];
            document.getElementById('searchCount').textContent = `${index + 1} of ${searchResults.length}`;
            document.querySelectorAll('.search-highlight').forEach(el => el.classList.remove('search-highlight'));
            revealPath(path);
        }
        function revealPath(path) {
            for (let i = 0; i < path.length; i++) {
                const subPath = path.slice(0, i + 1);
                if (i < path.length) {
                    const hash = hashPath(subPath);
                    const btn = document.getElementById(`toggle-${hash}`);
                    if (btn && btn.getAttribute('data-expanded') === 'false') handleToggle(btn);
                }
            }
            const hash = hashPath(path);
            const row = document.getElementById(`item-${hash}`);
            if (row) highlightRow(row);
            else {
                const parentPath = path.slice(0, path.length - 1);
                const container = document.getElementById(`children-${hashPath(parentPath)}`);
                const lastKey = path[path.length - 1];
                if (container) {
                    const rows = container.children;
                    const parentData = getValueByPath(jsonData, parentPath);
                    if (Array.isArray(parentData)) { if (rows[lastKey]) highlightRow(rows[lastKey].querySelector('.tree-item')); }
                    else {
                        for (let node of rows) {
                            const keySpan = node.querySelector('.tree-key');
                            if (keySpan && keySpan.textContent === String(lastKey)) { highlightRow(node.querySelector('.tree-item')); break; }
                        }
                    }
                }
            }
        }
        function highlightRow(row) { row.classList.add('search-highlight'); row.scrollIntoView({ behavior: 'smooth', block: 'center' }); }
        function resetSearch() { document.getElementById('searchInput').value = ''; resetSearchState(); document.querySelectorAll('.search-highlight').forEach(el => el.classList.remove('search-highlight')); }
        function triggerUpload() { document.getElementById('fileInput').click(); }
        function handleFile(input) {
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = e => { document.getElementById('jsonInput').value = e.target.result; parseAndDisplayTree(); };
                reader.readAsText(input.files[0]);
                input.value = '';
            }
        }
        const menu = document.getElementById('contextMenu');
        function showContextMenu(x, y) {
            menu.classList.add('visible');
            const menuW = menu.offsetWidth, menuH = menu.offsetHeight;
            let posX = x, posY = y;
            if (x + menuW > window.innerWidth) posX = x - menuW;
            if (y + menuH > window.innerHeight) posY = y - menuH;
            menu.style.left = `${posX}px`; menu.style.top = `${posY}px`;
        }
        function hideContextMenu() { menu.classList.remove('visible'); }
        function handleMenuAction(action) {
            if (!contextNode) return;
            const { path, element, isExpandable } = contextNode;
            const value = getValueByPath(jsonData, path);
            if (action === 'copyValue') {
                const text = typeof value === 'object' ? JSON.stringify(value, null, 2) : String(value);
                navigator.clipboard.writeText(text);
            } else if (action === 'copyPath') {
                let pathStr = '';
                path.forEach(p => pathStr += typeof p === 'number' ? `[${p}]` : `["${p}"]`);
                if(!pathStr) pathStr = "root";
                navigator.clipboard.writeText(pathStr);
            } else if (action === 'expandAll' && isExpandable) expandRecursive(element, path);
            else if (action === 'collapseAll' && isExpandable) collapseRecursive(element);
        }
        function expandRecursive(btn, path) {
            btn.setAttribute('data-expanded', 'true'); btn.innerHTML = svgs.expanded;
            const containerId = `children-${hashPath(path)}`; let container = document.getElementById(containerId);
            if (container) {
                const value = getValueByPath(jsonData, path);
                container.innerHTML = renderChildren(value, path, true);
                container.classList.remove('hidden');
            }
        }
        function collapseRecursive(btn) {
            btn.setAttribute('data-expanded', 'false'); btn.innerHTML = svgs.collapsed;
            const containerId = `children-${hashPath(JSON.parse(btn.getAttribute('data-path').replace(/&quot;/g, '"')))}`;
            const container = document.getElementById(containerId);
            if (container) { container.classList.add('hidden'); container.innerHTML = ''; }
        }

        function buildNodeHTML(data, key, pathArray, isRoot=false, forceExpand=false) {
            const type = Array.isArray(data) ? 'array' : (data === null ? 'null' : typeof data);
            const html = [];
            const pathStr = JSON.stringify(pathArray).replace(/"/g, '&quot;');
            const hash = hashPath(pathArray);
            
            html.push(`<div class="tree-node ${isRoot?'root':''}">`);
            if (!isRoot) html.push(`<div class="tree-line"></div>`);
            html.push(`<div class="tree-item" id="item-${hash}">`);

            if (type === 'object' || type === 'array') {
                const count = type === 'array' ? data.length : Object.keys(data).length;
                if (count > 0) {
                    const icon = forceExpand ? svgs.expanded : svgs.collapsed;
                    const exp = forceExpand ? 'true' : 'false';
                    html.push(`<span class="toggle" id="toggle-${hash}" data-expanded="${exp}" data-path="${pathStr}">${icon}</span>`);
                } else html.push(`<span class="toggle empty"></span>`);
            } else html.push(`<span class="toggle empty"></span>`);

            if (type === 'object') html.push(svgs.object);
            else if (type === 'array') html.push(svgs.array);
            else html.push(svgs.property);

            if (key !== 'root') {
                html.push(`<span class="tree-key">${escapeHtml(key)}</span>`);
                if (type !== 'object' && type !== 'array') html.push(`<span class="tree-colon">:</span>`);
            }

            if (type === 'object' || type === 'array') {
                const isArr = type === 'array';
                const count = isArr ? data.length : Object.keys(data).length;
                const b = isArr ? ['[', ']'] : ['{', '}'];
                html.push(`<span class="tree-inline"><span class="tree-bracket">${b[0]}</span>`);
                if (count > 0) html.push(`<span class="tree-count">${count} ${count === 1 ? 'item' : 'items'}</span>`);
                html.push(`<span class="tree-bracket">${b[1]}</span></span></div>`);
                if (count > 0) {
                    const cls = forceExpand ? '' : 'hidden';
                    const content = forceExpand ? renderChildren(data, pathArray, true) : '';
                    html.push(`<div class="tree-children ${cls}" id="children-${hash}">${content}</div>`);
                }
            } else {
                let val = String(data);
                if (type === 'string') val = `"${escapeHtml(data)}"`;
                html.push(`<span class="tree-value ${type}">${val}</span></div>`);
            }
            html.push(`</div>`);
            return html.join('');
        }

        function handleToggle(btn) {
            const isExp = btn.getAttribute('data-expanded') === 'true';
            const pathArray = JSON.parse(btn.getAttribute('data-path').replace(/&quot;/g, '"'));
            const container = document.getElementById(`children-${hashPath(pathArray)}`);
            if (!isExp) {
                btn.setAttribute('data-expanded', 'true'); btn.innerHTML = svgs.expanded;
                if (container) {
                    container.classList.remove('hidden');
                    if (container.innerHTML === '') container.innerHTML = renderChildren(getValueByPath(jsonData, pathArray), pathArray, false);
                }
            } else {
                btn.setAttribute('data-expanded', 'false'); btn.innerHTML = svgs.collapsed;
                if (container) container.classList.add('hidden');
            }
        }
        function renderChildren(data, parentPath, forceExpand) {
            if (!data) return '';
            const html = [];
            if (Array.isArray(data)) data.forEach((item, i) => html.push(buildNodeHTML(item, i, [...parentPath, i], false, forceExpand)));
            else Object.keys(data).forEach(k => html.push(buildNodeHTML(data[k], k, [...parentPath, k], false, forceExpand)));
            return html.join('');
        }
        function getValueByPath(obj, path) {
            let current = obj; for (let i = 0; i < path.length; i++) current = current[path[i]]; return current;
        }
        function hashPath(path) {
            let str = JSON.stringify(path), hash = 0;
            for (let i = 0; i < str.length; i++) hash = ((hash << 5) - hash) + str.charCodeAt(i) | 0;
            return Math.abs(hash);
        }
        function escapeHtml(text) {
            if (text === null || text === undefined) return '';
            const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
            return String(text).replace(/[&<>"']/g, m => map[m]);
        }
        if (localStorage.getItem('theme') === 'dark') document.body.classList.add('dark');
    </script>
</body>
</html>
